## 동시성(재고 정합성) 처리

### 문제
재고가 **1개인 상품**에 대해 동시에 2명이 주문(각 1개)할 때, 동시성 제어가 없으면 아래 문제가 발생할 수 있다.

- 재고가 **음수로 떨어짐**
- 주문이 중복 확정됨
- 트랜잭션 타이밍에 따라 결과가 비결정적(간헐적 실패/성공)

### 해결 전략
본 프로젝트는 **재고 정합성(음수 방지)** 을 최우선으로 두고, 재고 차감 시점에 **비관적 락(PESSIMISTIC_WRITE)** 을 사용한다.

- 재고 변경 책임은 `Item` 도메인에 캡슐화
  - `removeStock(count)`: 재고 차감 + 부족 시 예외
  - `addStock(count)`: 주문 취소 시 재고 복구
- 주문 생성 트랜잭션 내에서 재고 차감 직전에 락을 획득하여 동시 업데이트를 직렬화
- 트랜잭션을 짧게 유지하여 락 점유 시간을 최소화

### 동시성 테스트(재현/검증 방식)
멀티스레드 동시성 테스트는 “테스트 트랜잭션” 때문에 착시가 생기기 쉬워, 아래 원칙으로 구성했다.

#### 테스트 설계 원칙
1. 테스트 메서드/클래스에 `@Transactional`을 붙이지 않는다.
2. 테스트 데이터 준비는 `TransactionTemplate`로 감싸 **커밋된 상태**로 만든다.
3. 멀티스레드는 엔티티를 공유하지 않고 **ID만 공유**한다.
4. 최종 검증은 `TransactionTemplate`로 새 트랜잭션에서 조회하여 **DB 기준 값**으로 확인한다.
5. `startLatch`로 스레드를 동시에 출발시키고, `AtomicInteger`로 성공/실패 횟수를 검증한다.

#### 기대 결과
- 재고 1개에 2명이 동시에 주문 → **정확히 1건 성공, 1건 실패**
- 최종 재고는 반드시 **0**이어야 한다.

#### 테스트 코드 요약
- `startLatch`: 동시에 출발
- `doneLatch`: 모든 스레드 종료 대기
- 성공/실패 카운트: `success=1`, `fail=1` 검증
- DB 재조회: 캐시 영향 제거
